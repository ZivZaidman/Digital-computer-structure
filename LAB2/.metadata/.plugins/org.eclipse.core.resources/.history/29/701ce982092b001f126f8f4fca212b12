#include  "halGPIO.h"     // private library - HAL layer

int Count=0;

//--------------------------------------------------------------------
//             System Configuration
//--------------------------------------------------------------------
void sysConfig(void){
    GPIOconfig();
    TIMER0_A0_config();
    TIMER1_A1_config();
    TIMER1_A0_config();
    ADCconfig();
}
//-------------------------------------------------------------------
//            start ADC
//------------------------------------------------------------------
void startADC(){
    ADC10CTL0 |= ADC10ON + ADC10IE+ ENC + ADC10SC;
}
//-------------------------------------------------------------------
//            start Timer0 A0 - count 1 sec
//-------------------------------------------------------------------
void startTimer0A0(){
    TA0R = 0x00;
    TA0CCTL0 = CCIE;
    __bis_SR_register(LPM0_bits);     /* Enter Low Power Mode 0 */
    //enterLPM()
}
//--------------------------------------------------------------
//                 start Timer1 A1
//--------------------------------------------------------------
void statrTimer1A1(){

    TA1CTL |= TASSEL_2 + MC_1+ TAIE; //SMCLK, up mode
}
//------------------------------------------------------------------
//              stop timer1 A1
//------------------------------------------------------------------
void stopTimer1A1(){
    TA1CTL &= ~MC_1;
}
//------------------------------------------------------------------
//              shutdown ADC
//------------------------------------------------------------------
void ADCoff(){
    ADC10CTL0 &= ~ADC10ON;
}
//------------------------------------------------------------------
//              define TA1CCR for PWM
//------------------------------------------------------------------
void PWMTimer(int n){
    TA1CCR0 = n;
    TA1CCR1 = (int) n/2;
}
//--------------------------------------------------------------------
//                 start Timer1 A0 -state1
//--------------------------------------------------------------------
void  startTimer1A0(){
        TA1R=0x00;
        TA1CTL &= ~TAIFG;
        TA1CTL = TASSEL_2 + MC_2 + TAIE;
        __bis_SR_register(LPM0_bits+GIE);     /* Enter Low Power Mode 0 */        
}
//--------------------------------------------------------------------
//                  Print Frequncey - state1
//--------------------------------------------------------------------
/*void PrintFrequncey (F){
           lcd_cmd(0x02); //Return courser to start
           lcd_DATA
}*/
//--------------------------------------------------------------------
//            state 2 counter
//--------------------------------------------------------------------
void CountToLCD(seconds0,seconds1,minutes0,minutes1){
  
}
//--------------------------------------------------------------------
//                show To LCD - state2
//--------------------------------------------------------------------
void   showToLCD(seconds0,seconds1,minutes0,minutes1){
       lcd_data(minutes1);
       lcd_data(minutes0);
       lcd_data(0x3A);
       lcd_data(seconds1);
       lcd_data(seconds0);
}
//---------------------------------------------
//          turn off State1 Timer
//--------------------------------------------
void state1TimerOff(){
    TA1CTL = ~(TASSEL_2 + MC_2 + TAIE);
}
//-----------------------------------------------
/* - - - - - - - LCD interface - - - - - - - - -
//-----------------------------------------------
 *  This code will interface to a standard LCD controller
 *  It uses it in 4 or 8 bit mode.
 */
#include "msp430g2553.h"


//******************************************************************
// send a command to the LCD
//******************************************************************
void lcd_cmd(unsigned char c){

    LCD_WAIT; // may check LCD busy flag, or just delay a little, depending on lcd.h

    if (LCD_MODE == FOURBIT_MODE)
    {
        LCD_DATA_WRITE &= ~OUTPUT_DATA;// clear bits before new write
        LCD_DATA_WRITE |= ((c >> 4) & 0x0F) << LCD_DATA_OFFSET;
        lcd_strobe();
        LCD_DATA_WRITE &= ~OUTPUT_DATA;
        LCD_DATA_WRITE |= (c & (0x0F)) << LCD_DATA_OFFSET;
        lcd_strobe();
    }
    else
    {
        LCD_DATA_WRITE = c;
        lcd_strobe();
    }
}
//******************************************************************
// send data to the LCD
//******************************************************************
void lcd_data(unsigned char c){

    LCD_WAIT; // may check LCD busy flag, or just delay a little, depending on lcd.h

    LCD_DATA_WRITE &= ~OUTPUT_DATA;
    LCD_RS(1);
    if (LCD_MODE == FOURBIT_MODE)
    {
            LCD_DATA_WRITE &= ~OUTPUT_DATA;
                LCD_DATA_WRITE |= ((c >> 4) & 0x0F) << LCD_DATA_OFFSET;
        lcd_strobe();
                LCD_DATA_WRITE &= (0xF0 << LCD_DATA_OFFSET) | (0xF0 >> 8 - LCD_DATA_OFFSET);
                LCD_DATA_WRITE &= ~OUTPUT_DATA;
        LCD_DATA_WRITE |= (c & 0x0F) << LCD_DATA_OFFSET;
        lcd_strobe();
    }
    else
    {
        LCD_DATA_WRITE = c;
        lcd_strobe();
    }
    DelayMs(100);//--------------------dif
    LCD_RS(0);
}
//******************************************************************
// write a string of chars to the LCD
//******************************************************************
void lcd_puts(const char * s,int size){

  while(size){
        size--;
        lcd_data(*s++);
  }
}
//******************************************************************
// initialize the LCD
//******************************************************************
void lcd_init(){

    char init_value;

    if (LCD_MODE == FOURBIT_MODE) init_value = 0x3 << LCD_DATA_OFFSET;
        else init_value = 0x3F;

    LCD_RS_DIR(OUTPUT_PIN);
    LCD_EN_DIR(OUTPUT_PIN);
    LCD_RW_DIR(OUTPUT_PIN);
//    LCD_DATA_DIR |= OUTPUT_DATA;
    LCD_RS(0);
    LCD_EN(0);
    LCD_RW(0);

    DelayMs(15);
        LCD_DATA_WRITE &= ~OUTPUT_DATA;
    LCD_DATA_WRITE |= init_value;
    lcd_strobe();
    DelayMs(5);
        LCD_DATA_WRITE &= ~OUTPUT_DATA;
    LCD_DATA_WRITE |= init_value;
    lcd_strobe();
    DelayUs(200);
        LCD_DATA_WRITE &= ~OUTPUT_DATA;
    LCD_DATA_WRITE |= init_value;
    lcd_strobe();

    if (LCD_MODE == FOURBIT_MODE){
        LCD_WAIT; // may check LCD busy flag, or just delay a little, depending on lcd.h
                LCD_DATA_WRITE &= ~OUTPUT_DATA;
        LCD_DATA_WRITE |= 0x2 << LCD_DATA_OFFSET; // Set 4-bit mode
        lcd_strobe();
        lcd_cmd(0x28); // Function Set
    }
        else lcd_cmd(0x3C); // 8bit,two lines,5x10 dots

    lcd_cmd(0xF); //Display On, Cursor On, Cursor Blink
    lcd_cmd(0x1); //Display Clear
    lcd_cmd(0x6); //Entry Mode
    lcd_cmd(0x80); //Initialize DDRAM address to zero
}
//******************************************************************
// Delay usec functions
//******************************************************************
void DelayUs(unsigned int cnt){

    unsigned char i;
        for(i=cnt ; i>0 ; i--) __delay_cycles(1); // tha command asm("NOP") takes raphly 1usec

}
//******************************************************************
// Delay msec functions
//******************************************************************
void DelayMs(unsigned int cnt){

    unsigned char i;
        for(i=cnt ; i>0 ; i--) DelayUs(1000); // tha command asm("NOP") takes raphly 1usec

}
//******************************************************************
// lcd strobe functions
//******************************************************************
void lcd_strobe(){
  LCD_EN(1);
  __delay_cycles(1);
  __delay_cycles(1);
  LCD_EN(0);
}


//---------------------------------------------------------------------
//            Polling based Delay function
//---------------------------------------------------------------------
void delay(unsigned int t){  //
    volatile unsigned int i;

    for(i=t; i>0; i--);
}

//---------------------------------------------------------------------
//            Enter from LPM0 mode
//---------------------------------------------------------------------
void enterLPM(unsigned char LPM_level){
    if (LPM_level == 0x00)
      _BIS_SR(LPM0_bits);     /* Enter Low Power Mode 0 */
        else if(LPM_level == 0x01)
      _BIS_SR(LPM1_bits);     /* Enter Low Power Mode 1 */
        else if(LPM_level == 0x02)
      _BIS_SR(LPM2_bits);     /* Enter Low Power Mode 2 */
    else if(LPM_level == 0x03)
      _BIS_SR(LPM3_bits);     /* Enter Low Power Mode 3 */
        else if(LPM_level == 0x04)
      _BIS_SR(LPM4_bits);     /* Enter Low Power Mode 4 */
}
//---------------------------------------------------------------------
//            Enable interrupts
//---------------------------------------------------------------------
void enable_interrupts(){
  _BIS_SR(GIE);
}
//---------------------------------------------------------------------
//            Disable interrupts
//---------------------------------------------------------------------
void disable_interrupts(){
  _BIC_SR(GIE);
}

//*********************************************************************
//            TimerA0 Interrupt Service Routine - 1 sec counter
//*********************************************************************
#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)
#pragma vector = TIMER0_A0_VECTOR
__interrupt void Timer_A (void)
#elif defined(__GNUC__)
void __attribute__ ((interrupt(TIMER0_A0_VECTOR))) Timer_A (void)
#else
#error Compiler not supported!
#endif
{

    LPM0_EXIT;

}
//*********************************************************************
//            ADC10 Vector Interrupt Service Routine
//*********************************************************************
#pragma vector = ADC10_VECTOR
__interrupt void ADC10_ISR (void)
{
    __bic_SR_register_on_exit(CPUOFF);
    ADC10CTL0 &= ~ADC10IFG;
}



//*********************************************************************
//            TimerA0 Interrupt Service Routine
//*********************************************************************
#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)
#pragma vector = TIMER1_A1_VECTOR
__interrupt void TIMER1_A1_ISR(void)
#elif defined(__GNUC__)
void __attribute__ ((interrupt(TIMER1_A1_VECTOR))) TIMER1_A1_ISR (void)
#else
#error Compiler not supported!
#endif
{
  switch(__even_in_range(TA1IV, 0x0A))
  {
      case  TA1IV_NONE: break;              // Vector  0:  No interrupt
      case  TA1IV_TACCR1:                   // Vector  2:  TACCR1 CCIFG
          TA1CTL &= ~(TAIFG);
        break;
      case TA1IV_TACCR2:                    // Vector  4:  TACCR2 CCIFG
          if (TA1CCTL2 & CCI)                 // Capture Input Pin Status
                  {
                      // Rising Edge was captured
                      if (!Count)
                      {
                          REdge0 = TA1CCR2;
/*                          if(REdge0<=0){
                            REdge0=-1*REdge0;
                          }*/
                          Count++;
                      }
                      else
                      {
                          REdge1 = TA1CCR2;
/*                          if (REdge1<=0){
                            REdge1=-1*REdge1;
                          }*/
                          TA1CCTL2 &= ~CCIFG;
                          Count=0x0;
                          __bic_SR_register_on_exit(LPM0_bits + GIE);  // Exit LPM0 on return to main
                      }


                  }
          break;
//      case TA1IV_6: break;                  // Vector  6:  Reserved CCIFG
//      case TA1IV_8: break;                  // Vector  8:  Reserved CCIFG
      case TA1IV_TAIFG: break;              // Vector 10:  TAIFG
      default:  break;
  }
}



//********************************************************************
//            Port2 Interrupt Service Rotine
//*********************************************************************
#pragma vector=PORT2_VECTOR
  __interrupt void SWs_handler(void){
    
	delay(300);
        if (SWsArrIntPend & 0x01){
          if (state==state2){
            if(SWArrPort & 0x01){
              
                TA0R = 0x00;
                TA0CTL |= MC_3;
                SWsArrIntPend &= ~0x01;
            }
            else{
              TA0CTL &= ~MC_3;
              SWsArrIntPend &= ~0x01;
              
            }
          }
        }
  }
//********************************************************************
//            Port1 Interrupt Service Rotine
//*********************************************************************
#pragma vector=PORT1_VECTOR
  __interrupt void PBs_handler(void){
   
	delay(debounceVal);
        TA1CTL &= ~MC_2;     
        TA0CTL &= ~MC_3;
//---------------------------------------------------------------------
//            selector of transition between states
//---------------------------------------------------------------------
    if (PBsArrIntPend & PB0) {
        if (state != state1) {
        }
        state = state1;
        PBsArrIntPend &= ~PB0;  // Clear PB0 interrupt flag
    }
    else if (PBsArrIntPend & PB1) {
        state = state2;
        PBsArrIntPend &= ~PB1;  // Clear PB1 interrupt flag
    }
    else if (PBsArrIntPend & PB2) {
        state = state3;
        PBsArrIntPend &= ~PB2;  // Clear PB2 interrupt flag
    }else if (PBsArrIntPend & PB3){
        state = state4;
        PBsArrIntPend &= ~PB3;  // Clear PB3 interrupt flag
    }

//---------------------------------------------------------------------
//            Exit from a given LPM 
//---------------------------------------------------------------------	
        switch(lpm_mode){
		case mode0:
		 LPM0_EXIT; // must be called from ISR only
		 break;
		 
		case mode1:
		 LPM1_EXIT; // must be called from ISR only
		 break;
		 
		case mode2:
		 LPM2_EXIT; // must be called from ISR only
		 break;
                 
                case mode3:
		 LPM3_EXIT; // must be called from ISR only
		 break;
                 
                case mode4:
		 LPM4_EXIT; // must be called from ISR only
		 break;
	}
        
}

